# lab2 report

## lab思路
### 重写两个系统调用

根据提示，处理逻辑不变，但是传入的指针可能跨页(物理上)，直接靠虚拟地址访问，一旦数据在物理页上跨页，就会出现访问错误，思路就是直接找到那个虚拟地址对应的物理地址，直接将数据全部写入，保证数据在物理上连续即可，这样通过虚拟地址访问的物理地址可以直接往下访问xxx的数据，而不会出现错误。

### 虚拟内存分配和回收

分配和回收都存再错误的情况进行判断，这在代码的实现上需要注意，然后就是判重复。最后完成分配和回收即可。

## 问答

1. 64位页表项，高位保留(63-54),物理页号占44位(53-10),低10位是标记位，其中保留位(9-8),剩下的8位是有效的标记位从高到低依次为D（脏位，用于回收时是否写入内存）、A（表示页面是否被访问过。用于页面的缓存和替换）、G（表示页面是否为全局页面。当置为 1 时，页面对所有地址空间都可见，不会因上下文切换而刷新 TLB）、U（表示页面是否允许用户态访问）、X（表示页面是否可执行）、W（表示页面是否可写）、R（表示页面是否可读）、V（表示页面是否有效）

2. 

- 页表项无效、访问页权限不足，内存不够等等
- stval保存引发异常的虚拟地址、scause保存异常类型、sepc保存异常指令地址
- 节省程序的加载时间，等到程序真正使用的时候才去加载，从某种程度上说，也是节省了内存空间
- 10GB/4kB约为2.5x2^20个页,也是这么多页表项，一页放512个页表项，所以放索引的要5x2^10个页表。即三级页表5x2^10个，二级页表项10个，要一页，共需要5x2^10+1个页，每页4kB。共要内存约20MB
- 在页面最初分配时，不真正加载物理内存，而是仅建立虚拟地址映射，并将页表项标记为无效。当进程首次访问该页面时，触发缺页异常，此时才分配物理内存并更新页表，使该页面有效。
- 将页表项中的V设置为0即可。

### 建议
感觉加入了虚拟内存后，难度突然就上来了，突然不太适应，一些观念没有转换过来，比如数据跨页的问题。让我困惑了很久。这个部分课程的内容感觉可以多加一点。关于os启动后，所有的内存的分配啥的，希望能再详细一点，第一次有点吃力，不理解。


## 荣誉规则

1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

> 在完成这部分内容，我关于实现虚拟内存的一些数据写入原理产生疑惑(包括局部变量和指针跨页不跨页的问题，和如何进行数据的写入问题)，向队内成员提出疑问并得到解答，在思路上获得提示。

2. 此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

> 我参考的是实验提供的指导，部分原理理解部分参考的是详细版的说明，在代码理解上，我使用了gpt等工具辅助理解

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。